<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net461;netstandard2.0;netstandard2.1;net5.0</TargetFrameworks>
    <nullable>enable</nullable>

    <Features>strict</Features>
    <PackageId>StringlyTyped.ValueObjects</PackageId>
    <Version>1.0.0</Version>
    <PackageVersion>1.0.0</PackageVersion>
    <PackageProjectUrl>https://github.com/SteveDunn/StringlyTyped</PackageProjectUrl>

    <Authors>Steve Dunn</Authors>
    <Copyright>Copyright Steve Dunn</Copyright>
    <Title>StringlyTyped - Value Objects that help combat 'Stringly Typed' software and Primitive Obsession.  Be confident with your types!</Title>
    <PackageTags>stringlytyped;primitive;obsession;valuetype;valuetypes;valueobj;valueobjects;ddd</PackageTags>
    <PackageIcon>gradient_128x128.png</PackageIcon>
    <PackageLicenseExpression>Apache-2.0</PackageLicenseExpression>
    <PublishRepositoryUrl>true</PublishRepositoryUrl>
    <IncludeSymbols>true</IncludeSymbols>
    <SymbolPackageFormat>snupkg</SymbolPackageFormat>
    <EmbedUntrackedSources>true</EmbedUntrackedSources>
    <Deterministic>true</Deterministic>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <RepositoryUrl>https://github.com/SteveDunn/StringlyTyped</RepositoryUrl>
    <Description>This package contains a very simple implementation of a ValueObject in .NET.

A ValueObject is a strongly typed (strongly, not stringly) domain object that is immutable.

Instead of
``` cs
int customerId = 42;
``` we have

``` cs
var customerId = CustomerId.From(42);
```

CustomerId derives from this package's ValueObject type:

``` cs
public class CustomerId : ValueObject&lt;int, CustomerId&gt;
{
}
```

Here it is again with some validation

``` cs
public class CustomerId : ValueObject&lt;int, CustomerId&gt;
{
    public override Validation Validate() =&gt; Value &gt; 0 
      ? Validation.Ok 
      : Validation.Invalid("Customer IDs cannot be zero or negative.");
}
```
This allows us to have more strongly typed domain objects instead of primitives, which makes the code easier to read and enforces better method signatures, so instead of:

``` cs
public void DoSomething(int customerId, int supplierId, int amount)
```
we can have:

``` cs
public void DoSomething(CustomerId customerId, SupplierId supplierId, Amount amount)

Now, callers can't mess up the ordering or parameters and accidentally pass us a Supplier ID in place of a Customer ID.

It also means that validation is in just one place. You can't introduce bad objects into your domain, therefore you can assume that in your domain every ValueObject is valid. Handy.</Description>

  </PropertyGroup>

  <ItemGroup>
    <None Include="..\..\assets\logo\gradient_128x128.png" Pack="true" PackagePath="" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.SourceLink.GitHub" Version="1.0.0" PrivateAssets="All" />
    <PackageReference Include="MinVer" Version="2.3.1" PrivateAssets="All" />
    <PackageReference Include="System.Text.Json" Version="5.0.2" />
  </ItemGroup>


</Project>
